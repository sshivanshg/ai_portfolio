"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uuidv7";
exports.ids = ["vendor-chunks/uuidv7"];
exports.modules = {

/***/ "(rsc)/./node_modules/uuidv7/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/uuidv7/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uuidv4obj = exports.uuidv4 = exports.uuidv7obj = exports.uuidv7 = exports.V7Generator = exports.UUID = void 0;\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nclass UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\nexports.UUID = UUID;\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */\nclass V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\nexports.V7Generator = V7Generator;\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv7 = () => (0, exports.uuidv7obj)().toString();\nexports.uuidv7 = uuidv7;\n/** Generates a UUIDv7 object. */\nconst uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\nexports.uuidv7obj = uuidv7obj;\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv4 = () => (0, exports.uuidv4obj)().toString();\nexports.uuidv4 = uuidv4;\n/** Generates a UUIDv4 object. */\nconst uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\nexports.uuidv4obj = uuidv4obj;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXVpZHY3L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEdBQUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksR0FBRyxHQUFHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxHQUFHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYyxLQUFLLGdCQUFnQjtBQUNoRSxnQkFBZ0IsZ0JBQWdCLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixRQUFRLDJCQUEyQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy91dWlkdjcvZGlzdC9pbmRleC5janM/Y2VmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogdXVpZHY3OiBBbiBleHBlcmltZW50YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHByb3Bvc2VkIFVVSUQgVmVyc2lvbiA3XG4gKlxuICogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuICogQGNvcHlyaWdodCAyMDIxLTIwMjMgTGlvc0tcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV1aWR2NG9iaiA9IGV4cG9ydHMudXVpZHY0ID0gZXhwb3J0cy51dWlkdjdvYmogPSBleHBvcnRzLnV1aWR2NyA9IGV4cG9ydHMuVjdHZW5lcmF0b3IgPSBleHBvcnRzLlVVSUQgPSB2b2lkIDA7XG5jb25zdCBESUdJVFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKiBSZXByZXNlbnRzIGEgVVVJRCBhcyBhIDE2LWJ5dGUgYnl0ZSBhcnJheS4gKi9cbmNsYXNzIFVVSUQge1xuICAgIC8qKiBAcGFyYW0gYnl0ZXMgLSBUaGUgMTYtYnl0ZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uLiAqL1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgZnJvbSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24sIGEgMTYtYnl0ZSBieXRlIGFycmF5XG4gICAgICogY29udGFpbmluZyB0aGUgYmluYXJ5IFVVSUQgcmVwcmVzZW50YXRpb24gaW4gdGhlIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgTk9UIHNoYWxsb3ctY29weSB0aGUgYXJndW1lbnQsIGFuZCB0aHVzIHRoZSBjcmVhdGVkIG9iamVjdFxuICAgICAqIGhvbGRzIHRoZSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHRocm93cyBUeXBlRXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJndW1lbnQgaXMgbm90IDE2LlxuICAgICAqL1xuICAgIHN0YXRpYyBvZklubmVyKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IDEyOC1iaXQgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBieXRlIGFycmF5IGZyb20gVVVJRHY3IGZpZWxkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1bml4VHNNcyAtIEEgNDgtYml0IGB1bml4X3RzX21zYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcmFuZEEgLSBBIDEyLWJpdCBgcmFuZF9hYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcmFuZEJIaSAtIFRoZSBoaWdoZXIgMzAgYml0cyBvZiA2Mi1iaXQgYHJhbmRfYmAgZmllbGQgdmFsdWUuXG4gICAgICogQHBhcmFtIHJhbmRCTG8gLSBUaGUgbG93ZXIgMzIgYml0cyBvZiA2Mi1iaXQgYHJhbmRfYmAgZmllbGQgdmFsdWUuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGFueSBmaWVsZCB2YWx1ZSBpcyBvdXQgb2YgdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUZpZWxkc1Y3KHVuaXhUc01zLCByYW5kQSwgcmFuZEJIaSwgcmFuZEJMbykge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodW5peFRzTXMpIHx8XG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihyYW5kQSkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRCSGkpIHx8XG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihyYW5kQkxvKSB8fFxuICAgICAgICAgICAgdW5peFRzTXMgPCAwIHx8XG4gICAgICAgICAgICByYW5kQSA8IDAgfHxcbiAgICAgICAgICAgIHJhbmRCSGkgPCAwIHx8XG4gICAgICAgICAgICByYW5kQkxvIDwgMCB8fFxuICAgICAgICAgICAgdW5peFRzTXMgPiAyODE0NzQ5NzY3MTA2NTUgfHxcbiAgICAgICAgICAgIHJhbmRBID4gMHhmZmYgfHxcbiAgICAgICAgICAgIHJhbmRCSGkgPiAxMDczNzQxODIzIHx8XG4gICAgICAgICAgICByYW5kQkxvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGZpZWxkIHZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBieXRlc1swXSA9IHVuaXhUc01zIC8gMiAqKiA0MDtcbiAgICAgICAgYnl0ZXNbMV0gPSB1bml4VHNNcyAvIDIgKiogMzI7XG4gICAgICAgIGJ5dGVzWzJdID0gdW5peFRzTXMgLyAyICoqIDI0O1xuICAgICAgICBieXRlc1szXSA9IHVuaXhUc01zIC8gMiAqKiAxNjtcbiAgICAgICAgYnl0ZXNbNF0gPSB1bml4VHNNcyAvIDIgKiogODtcbiAgICAgICAgYnl0ZXNbNV0gPSB1bml4VHNNcztcbiAgICAgICAgYnl0ZXNbNl0gPSAweDcwIHwgKHJhbmRBID4+PiA4KTtcbiAgICAgICAgYnl0ZXNbN10gPSByYW5kQTtcbiAgICAgICAgYnl0ZXNbOF0gPSAweDgwIHwgKHJhbmRCSGkgPj4+IDI0KTtcbiAgICAgICAgYnl0ZXNbOV0gPSByYW5kQkhpID4+PiAxNjtcbiAgICAgICAgYnl0ZXNbMTBdID0gcmFuZEJIaSA+Pj4gODtcbiAgICAgICAgYnl0ZXNbMTFdID0gcmFuZEJIaTtcbiAgICAgICAgYnl0ZXNbMTJdID0gcmFuZEJMbyA+Pj4gMjQ7XG4gICAgICAgIGJ5dGVzWzEzXSA9IHJhbmRCTG8gPj4+IDE2O1xuICAgICAgICBieXRlc1sxNF0gPSByYW5kQkxvID4+PiA4O1xuICAgICAgICBieXRlc1sxNV0gPSByYW5kQkxvO1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBieXRlIGFycmF5IGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICAgKlxuICAgICAqIC0gMzItZGlnaXQgaGV4YWRlY2ltYWwgZm9ybWF0IHdpdGhvdXQgaHlwaGVuczogYDAxODlkY2Q1NTMxMTdkNDA4ZGIwOTQ5NmEyZWVmMzdiYFxuICAgICAqIC0gOC00LTQtNC0xMiBoeXBoZW5hdGVkIGZvcm1hdDogYDAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3YmBcbiAgICAgKiAtIEh5cGhlbmF0ZWQgZm9ybWF0IHdpdGggc3Vycm91bmRpbmcgYnJhY2VzOiBgezAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3Yn1gXG4gICAgICogLSBSRkMgNDEyMiBVUk4gZm9ybWF0OiBgdXJuOnV1aWQ6MDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdiYFxuICAgICAqXG4gICAgICogTGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZXMgcmVwcmVzZW50cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgU3ludGF4RXJyb3IgaWYgdGhlIGFyZ3VtZW50IGNvdWxkIG5vdCBwYXJzZSBhcyBhIHZhbGlkIFVVSUQgc3RyaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh1dWlkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IGhleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoICh1dWlkLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICBoZXggPSAoX2EgPSAvXlswLTlhLWZdezMyfSQvaS5leGVjKHV1aWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgICAgIGhleCA9XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IC9eKFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KSQvaVxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgxLCA2KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICBoZXggPVxuICAgICAgICAgICAgICAgICAgICAoX2MgPSAvXlxceyhbMC05YS1mXXs4fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezEyfSlcXH0kL2lcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjKHV1aWQpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2xpY2UoMSwgNikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgaGV4ID1cbiAgICAgICAgICAgICAgICAgICAgKF9kID0gL151cm46dXVpZDooWzAtOWEtZl17OH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXsxMn0pJC9pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNsaWNlKDEsIDYpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgOCksIDE2KTtcbiAgICAgICAgICAgICAgICBpbm5lcltpICsgMF0gPSBuID4+PiAyNDtcbiAgICAgICAgICAgICAgICBpbm5lcltpICsgMV0gPSBuID4+PiAxNjtcbiAgICAgICAgICAgICAgICBpbm5lcltpICsgMl0gPSBuID4+PiA4O1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAzXSA9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVVSUQoaW5uZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiY291bGQgbm90IHBhcnNlIFVVSUQgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSA4LTQtNC00LTEyIGNhbm9uaWNhbCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiAoYDAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3YmApLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBESUdJVFMuY2hhckF0KHRoaXMuYnl0ZXNbaV0gPj4+IDQpO1xuICAgICAgICAgICAgdGV4dCArPSBESUdJVFMuY2hhckF0KHRoaXMuYnl0ZXNbaV0gJiAweGYpO1xuICAgICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiLVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgMzItZGlnaXQgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gd2l0aG91dCBoeXBoZW5zXG4gICAgICogKGAwMTg5ZGNkNTUzMTE3ZDQwOGRiMDk0OTZhMmVlZjM3YmApLlxuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBESUdJVFMuY2hhckF0KHRoaXMuYnl0ZXNbaV0gPj4+IDQpO1xuICAgICAgICAgICAgdGV4dCArPSBESUdJVFMuY2hhckF0KHRoaXMuYnl0ZXNbaV0gJiAweGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKiogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi4gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgdGhlIHZhcmlhbnQgZmllbGQgdmFsdWUgb2YgdGhlIFVVSUQgb3IsIGlmIGFwcHJvcHJpYXRlLCBcIk5JTFwiIG9yXG4gICAgICogXCJNQVhcIi5cbiAgICAgKlxuICAgICAqIEZvciBjb252ZW5pZW5jZSwgdGhpcyBtZXRob2QgcmVwb3J0cyBcIk5JTFwiIG9yIFwiTUFYXCIgaWYgYHRoaXNgIHJlcHJlc2VudHNcbiAgICAgKiB0aGUgTmlsIG9yIE1heCBVVUlELCBhbHRob3VnaCB0aGUgTmlsIGFuZCBNYXggVVVJRHMgYXJlIHRlY2huaWNhbGx5XG4gICAgICogc3Vic3VtZWQgdW5kZXIgdGhlIHZhcmlhbnRzIGAwYjBgIGFuZCBgMGIxMTFgLCByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgZ2V0VmFyaWFudCgpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuYnl0ZXNbOF0gPj4+IDQ7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAwYjAxMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmV2ZXJ5KChlKSA9PiBlID09PSAwKSA/IFwiTklMXCIgOiBcIlZBUl8wXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAwYjEwMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlZBUl8xMFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIxMTAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJWQVJfMTEwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAwYjExMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmV2ZXJ5KChlKSA9PiBlID09PSAweGZmKSA/IFwiTUFYXCIgOiBcIlZBUl9SRVNFUlZFRFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBmaWVsZCB2YWx1ZSBvZiB0aGUgVVVJRCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgVVVJRCBkb2VzXG4gICAgICogbm90IGhhdmUgdGhlIHZhcmlhbnQgZmllbGQgdmFsdWUgb2YgYDBiMTBgLlxuICAgICAqL1xuICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnQoKSA9PT0gXCJWQVJfMTBcIiA/IHRoaXMuYnl0ZXNbNl0gPj4+IDQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGFuIG9iamVjdCBmcm9tIGB0aGlzYC4gKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnl0ZXMuc2xpY2UoMCkpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGB0aGlzYCBpcyBlcXVpdmFsZW50IHRvIGBvdGhlcmAuICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZWdhdGl2ZSBpbnRlZ2VyLCB6ZXJvLCBvciBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGB0aGlzYCBpcyBsZXNzXG4gICAgICogdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLCByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHRoaXMuYnl0ZXNbaV0gLSBvdGhlci5ieXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc2lnbihkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLlVVSUQgPSBVVUlEO1xuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIG1vbm90b25pYyBjb3VudGVyIHN0YXRlLlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgQVBJcyB0byB1dGlsaXplIGEgc2VwYXJhdGUgY291bnRlciBzdGF0ZSBmcm9tIHRoYXQgb2YgdGhlXG4gKiBnbG9iYWwgZ2VuZXJhdG9yIHVzZWQgYnkge0BsaW5rIHV1aWR2N30gYW5kIHtAbGluayB1dWlkdjdvYmp9LiBJbiBhZGRpdGlvbiB0b1xuICogdGhlIGRlZmF1bHQge0BsaW5rIGdlbmVyYXRlfSBtZXRob2QsIHRoaXMgY2xhc3MgaGFzIHtAbGluayBnZW5lcmF0ZU9yQWJvcnR9XG4gKiB0aGF0IGlzIHVzZWZ1bCB0byBhYnNvbHV0ZWx5IGd1YXJhbnRlZSB0aGUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIG9yZGVyIG9mXG4gKiBnZW5lcmF0ZWQgVVVJRHMuIFNlZSB0aGVpciByZXNwZWN0aXZlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbmNsYXNzIFY3R2VuZXJhdG9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZ2VuZXJhdG9yIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLCBvclxuICAgICAqIHdpdGggdGhlIHNwZWNpZmllZCBvbmUgaWYgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBUaGUgc3BlY2lmaWVkIHJhbmRvbVxuICAgICAqIG51bWJlciBnZW5lcmF0b3Igc2hvdWxkIGJlIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBhbmQgc2VjdXJlbHkgc2VlZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhbmRvbU51bWJlckdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMucmFuZG9tID0gcmFuZG9tTnVtYmVyR2VuZXJhdG9yICE9PSBudWxsICYmIHJhbmRvbU51bWJlckdlbmVyYXRvciAhPT0gdm9pZCAwID8gcmFuZG9tTnVtYmVyR2VuZXJhdG9yIDogZ2V0RGVmYXVsdFJhbmRvbSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgb3IgcmVzZXRzIHRoZVxuICAgICAqIGdlbmVyYXRvciB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgVVVJRCBieSByZXVzaW5nIHRoZSBwcmV2aW91c1xuICAgICAqIHRpbWVzdGFtcCBldmVuIGlmIHRoZSB1cC10by1kYXRlIHRpbWVzdGFtcCBpcyBzbWFsbGVyIHRoYW4gdGhlIGltbWVkaWF0ZWx5XG4gICAgICogcHJlY2VkaW5nIFVVSUQncy4gSG93ZXZlciwgd2hlbiBzdWNoIGEgY2xvY2sgcm9sbGJhY2sgaXMgY29uc2lkZXJlZFxuICAgICAqIHNpZ25pZmljYW50IChpLmUuLCBieSBtb3JlIHRoYW4gdGVuIHNlY29uZHMpLCB0aGlzIG1ldGhvZCByZXNldHMgdGhlXG4gICAgICogZ2VuZXJhdG9yIGFuZCByZXR1cm5zIGEgbmV3IFVVSUQgYmFzZWQgb24gdGhlIGdpdmVuIHRpbWVzdGFtcCwgYnJlYWtpbmcgdGhlXG4gICAgICogaW5jcmVhc2luZyBvcmRlciBvZiBVVUlEcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fSBmb3IgdGhlIG90aGVyIG1vZGUgb2YgZ2VuZXJhdGlvbiBhbmRcbiAgICAgKiB7QGxpbmsgZ2VuZXJhdGVPclJlc2V0Q29yZX0gZm9yIHRoZSBsb3ctbGV2ZWwgcHJpbWl0aXZlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU9yUmVzZXRDb3JlKERhdGUubm93KCksIDEwMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NyBvYmplY3QgZnJvbSB0aGUgY3VycmVudCB0aW1lc3RhbXAsIG9yIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgVVVJRCBieSByZXVzaW5nIHRoZSBwcmV2aW91c1xuICAgICAqIHRpbWVzdGFtcCBldmVuIGlmIHRoZSB1cC10by1kYXRlIHRpbWVzdGFtcCBpcyBzbWFsbGVyIHRoYW4gdGhlIGltbWVkaWF0ZWx5XG4gICAgICogcHJlY2VkaW5nIFVVSUQncy4gSG93ZXZlciwgd2hlbiBzdWNoIGEgY2xvY2sgcm9sbGJhY2sgaXMgY29uc2lkZXJlZFxuICAgICAqIHNpZ25pZmljYW50IChpLmUuLCBieSBtb3JlIHRoYW4gdGVuIHNlY29uZHMpLCB0aGlzIG1ldGhvZCBhYm9ydHMgYW5kXG4gICAgICogcmV0dXJucyBgdW5kZWZpbmVkYCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgZ2VuZXJhdGV9IGZvciB0aGUgb3RoZXIgbW9kZSBvZiBnZW5lcmF0aW9uIGFuZFxuICAgICAqIHtAbGluayBnZW5lcmF0ZU9yQWJvcnRDb3JlfSBmb3IgdGhlIGxvdy1sZXZlbCBwcmltaXRpdmUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVPckFib3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU9yQWJvcnRDb3JlKERhdGUubm93KCksIDEwMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NyBvYmplY3QgZnJvbSB0aGUgYHVuaXhUc01zYCBwYXNzZWQsIG9yIHJlc2V0cyB0aGVcbiAgICAgKiBnZW5lcmF0b3IgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIHtAbGluayBnZW5lcmF0ZX0gZXhjZXB0IHRoYXQgaXQgdGFrZXMgYSBjdXN0b21cbiAgICAgKiB0aW1lc3RhbXAgYW5kIGNsb2NrIHJvbGxiYWNrIGFsbG93YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb2xsYmFja0FsbG93YW5jZSAtIFRoZSBhbW91bnQgb2YgYHVuaXhUc01zYCByb2xsYmFjayB0aGF0IGlzXG4gICAgICogY29uc2lkZXJlZCBzaWduaWZpY2FudC4gQSBzdWdnZXN0ZWQgdmFsdWUgaXMgYDEwXzAwMGAgKG1pbGxpc2Vjb25kcykuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGB1bml4VHNNc2AgaXMgbm90IGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXIuXG4gICAgICovXG4gICAgZ2VuZXJhdGVPclJlc2V0Q29yZSh1bml4VHNNcywgcm9sbGJhY2tBbGxvd2FuY2UpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZW5lcmF0ZU9yQWJvcnRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXNldCBzdGF0ZSBhbmQgcmVzdW1lXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IDA7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2VuZXJhdGVPckFib3J0Q29yZSh1bml4VHNNcywgcm9sbGJhY2tBbGxvd2FuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NyBvYmplY3QgZnJvbSB0aGUgYHVuaXhUc01zYCBwYXNzZWQsIG9yIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8ge0BsaW5rIGdlbmVyYXRlT3JBYm9ydH0gZXhjZXB0IHRoYXQgaXQgdGFrZXMgYVxuICAgICAqIGN1c3RvbSB0aW1lc3RhbXAgYW5kIGNsb2NrIHJvbGxiYWNrIGFsbG93YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb2xsYmFja0FsbG93YW5jZSAtIFRoZSBhbW91bnQgb2YgYHVuaXhUc01zYCByb2xsYmFjayB0aGF0IGlzXG4gICAgICogY29uc2lkZXJlZCBzaWduaWZpY2FudC4gQSBzdWdnZXN0ZWQgdmFsdWUgaXMgYDEwXzAwMGAgKG1pbGxpc2Vjb25kcykuXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGB1bml4VHNNc2AgaXMgbm90IGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXIuXG4gICAgICovXG4gICAgZ2VuZXJhdGVPckFib3J0Q29yZSh1bml4VHNNcywgcm9sbGJhY2tBbGxvd2FuY2UpIHtcbiAgICAgICAgY29uc3QgTUFYX0NPVU5URVIgPSA0Mzk4MDQ2NTExMTAzO1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodW5peFRzTXMpIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA8IDEgfHxcbiAgICAgICAgICAgIHVuaXhUc01zID4gMjgxNDc0OTc2NzEwNjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImB1bml4VHNNc2AgbXVzdCBiZSBhIDQ4LWJpdCBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvbGxiYWNrQWxsb3dhbmNlIDwgMCB8fCByb2xsYmFja0FsbG93YW5jZSA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJgcm9sbGJhY2tBbGxvd2FuY2VgIG91dCBvZiByZWFzb25hYmxlIHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml4VHNNcyA+IHRoaXMudGltZXN0YW1wKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHVuaXhUc01zO1xuICAgICAgICAgICAgdGhpcy5yZXNldENvdW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bml4VHNNcyArIHJvbGxiYWNrQWxsb3dhbmNlID49IHRoaXMudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAvLyBnbyBvbiB3aXRoIHByZXZpb3VzIHRpbWVzdGFtcCBpZiBuZXcgb25lIGlzIG5vdCBtdWNoIHNtYWxsZXJcbiAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xuICAgICAgICAgICAgaWYgKHRoaXMuY291bnRlciA+IE1BWF9DT1VOVEVSKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRpbWVzdGFtcCBhdCBjb3VudGVyIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXArKztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q291bnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWJvcnQgaWYgY2xvY2sgd2VudCBiYWNrd2FyZHMgdG8gdW5iZWFyYWJsZSBleHRlbnRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVVSUQuZnJvbUZpZWxkc1Y3KHRoaXMudGltZXN0YW1wLCBNYXRoLnRydW5jKHRoaXMuY291bnRlciAvIDIgKiogMzApLCB0aGlzLmNvdW50ZXIgJiAoMiAqKiAzMCAtIDEpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkpO1xuICAgIH1cbiAgICAvKiogSW5pdGlhbGl6ZXMgdGhlIGNvdW50ZXIgYXQgYSA0Mi1iaXQgcmFuZG9tIGludGVnZXIuICovXG4gICAgcmVzZXRDb3VudGVyKCkge1xuICAgICAgICB0aGlzLmNvdW50ZXIgPVxuICAgICAgICAgICAgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpICogMHg0MDAgKyAodGhpcy5yYW5kb20ubmV4dFVpbnQzMigpICYgMHgzZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY0IG9iamVjdCB1dGlsaXppbmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGluc2lkZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdlbmVyYXRlVjQoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoVWludDMyQXJyYXkub2YodGhpcy5yYW5kb20ubmV4dFVpbnQzMigpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpKS5idWZmZXIpO1xuICAgICAgICBieXRlc1s2XSA9IDB4NDAgfCAoYnl0ZXNbNl0gPj4+IDQpO1xuICAgICAgICBieXRlc1s4XSA9IDB4ODAgfCAoYnl0ZXNbOF0gPj4+IDIpO1xuICAgICAgICByZXR1cm4gVVVJRC5vZklubmVyKGJ5dGVzKTtcbiAgICB9XG59XG5leHBvcnRzLlY3R2VuZXJhdG9yID0gVjdHZW5lcmF0b3I7XG4vKiogUmV0dXJucyB0aGUgZGVmYXVsdCByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBhdmFpbGFibGUgaW4gdGhlIGVudmlyb25tZW50LiAqL1xuY29uc3QgZ2V0RGVmYXVsdFJhbmRvbSA9ICgpID0+IHtcbiAgICAvLyBkZXRlY3QgV2ViIENyeXB0byBBUElcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcmVkQ3J5cHRvUmFuZG9tKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmYWxsIGJhY2sgb24gTWF0aC5yYW5kb20oKSB1bmxlc3MgdGhlIGZsYWcgaXMgc2V0IHRvIHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBVVUlEVjdfREVOWV9XRUFLX1JORyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBVVUlEVjdfREVOWV9XRUFLX1JORykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIFJORyBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHRVaW50MzI6ICgpID0+IE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIDY1NTM2KSAqIDY1NTM2ICtcbiAgICAgICAgICAgICAgICBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiA2NTUzNiksXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogV3JhcHMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKWAgdG8gZW5hYmxlIGJ1ZmZlcmluZzsgdGhpcyB1c2VzIGEgc21hbGxcbiAqIGJ1ZmZlciBieSBkZWZhdWx0IHRvIGF2b2lkIGJvdGggdW5iZWFyYWJsZSB0aHJvdWdocHV0IGRlY2xpbmUgaW4gc29tZVxuICogZW52aXJvbm1lbnRzIGFuZCB0aGUgd2FzdGUgb2YgdGltZSBhbmQgc3BhY2UgZm9yIHVudXNlZCB2YWx1ZXMuXG4gKi9cbmNsYXNzIEJ1ZmZlcmVkQ3J5cHRvUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDMyQXJyYXkoOCk7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gMHhmZmZmO1xuICAgIH1cbiAgICBuZXh0VWludDMyKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IgPj0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5jdXJzb3IrK107XG4gICAgfVxufVxubGV0IGRlZmF1bHRHZW5lcmF0b3I7XG4vKipcbiAqIEdlbmVyYXRlcyBhIFVVSUR2NyBzdHJpbmcuXG4gKlxuICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogKFwieHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4XCIpLlxuICovXG5jb25zdCB1dWlkdjcgPSAoKSA9PiAoMCwgZXhwb3J0cy51dWlkdjdvYmopKCkudG9TdHJpbmcoKTtcbmV4cG9ydHMudXVpZHY3ID0gdXVpZHY3O1xuLyoqIEdlbmVyYXRlcyBhIFVVSUR2NyBvYmplY3QuICovXG5jb25zdCB1dWlkdjdvYmogPSAoKSA9PiAoZGVmYXVsdEdlbmVyYXRvciB8fCAoZGVmYXVsdEdlbmVyYXRvciA9IG5ldyBWN0dlbmVyYXRvcigpKSkuZ2VuZXJhdGUoKTtcbmV4cG9ydHMudXVpZHY3b2JqID0gdXVpZHY3b2JqO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBVVUlEdjQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIFRoZSA4LTQtNC00LTEyIGNhbm9uaWNhbCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIChcInh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFwiKS5cbiAqL1xuY29uc3QgdXVpZHY0ID0gKCkgPT4gKDAsIGV4cG9ydHMudXVpZHY0b2JqKSgpLnRvU3RyaW5nKCk7XG5leHBvcnRzLnV1aWR2NCA9IHV1aWR2NDtcbi8qKiBHZW5lcmF0ZXMgYSBVVUlEdjQgb2JqZWN0LiAqL1xuY29uc3QgdXVpZHY0b2JqID0gKCkgPT4gKGRlZmF1bHRHZW5lcmF0b3IgfHwgKGRlZmF1bHRHZW5lcmF0b3IgPSBuZXcgVjdHZW5lcmF0b3IoKSkpLmdlbmVyYXRlVjQoKTtcbmV4cG9ydHMudXVpZHY0b2JqID0gdXVpZHY0b2JqO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uuidv7/dist/index.cjs\n");

/***/ })

};
;